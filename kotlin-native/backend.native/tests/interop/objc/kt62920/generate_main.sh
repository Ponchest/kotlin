#!/bin/sh

OUTPUT_FILE=main.kt
MAX_STAGE=1000
THREADS_COUNT=10

rm $OUTPUT_FILE

# Prelude
cat <<EOF >> $OUTPUT_FILE
// DO NOT EDIT BY HAND
// This file is generated by generate_main.sh.
@file:OptIn(kotlin.ExperimentalStdlibApi::class)

import objclib.*

import kotlin.concurrent.AtomicInt
import kotlin.concurrent.AtomicIntArray
import kotlin.native.concurrent.*

EOF

# Define all the classes
for i in $(seq 1 $MAX_STAGE); do
  echo "class C${i}" >> $OUTPUT_FILE
done

# Actual test procedure.
cat <<EOF >> $OUTPUT_FILE

const val MAX_STAGE = $MAX_STAGE

val canRunStage = AtomicInt(0)
val hasRunStage = AtomicIntArray(MAX_STAGE + 1)

fun test() {
    hasRunStage.getAndIncrement(0)
EOF

# Define all test cases
for i in $(seq 1 $MAX_STAGE); do
cat <<EOF >> $OUTPUT_FILE

    while (canRunStage.value != ${i}) {}
    useObject(C${i}())
    hasRunStage.getAndIncrement(${i})
EOF
done

# Close the test procedure. And define test entry point.
cat <<EOF >> $OUTPUT_FILE
}

fun main() {
    val workers = Array(${THREADS_COUNT}) { Worker.start() }

    workers.forEach { it.executeAfter(0, ::test) }

    while (hasRunStage[0] != workers.size) {}
    (1..MAX_STAGE).forEach { stage ->
        canRunStage.value = stage
        while (hasRunStage[stage] != workers.size) {}
    }

    workers.forEach { it.requestTermination().result }
}
EOF